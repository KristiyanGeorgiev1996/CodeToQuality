# 🧪 QA Basics Revision

Quality Assurance (QA) is a fundamental part of software development, ensuring that applications work as intended and meet user expectations 💻. **Software testing** is the practice of exercising and analyzing software to verify that it meets specified requirements and to detect any discrepancies or defects ⚡. It is a systematic process aimed at improving software quality, minimizing risks, and providing confidence to stakeholders.

Software testing typically involves several stages: **test planning and analysis**, **test design and execution**, **reporting and evaluation**, and **maintenance** 📝. The main objectives of testing are to prevent defects, confirm expected behavior, verify requirements, reduce risks, and ensure compliance with legal and contractual standards ✅.

---

## 🧠 Importance of Software Testing

Testing is crucial for reliability and safety, especially in critical applications like healthcare, aviation, or financial systems 🏥✈️💰. Early detection of defects significantly reduces costs and prevents potential failures. QA testers also navigate human factors such as confirmation bias or the perception that testing is "destructive," requiring strong communication and collaboration skills 🗣️🤝.

---

## 🎯 Seven Principles of Software Testing

Software testing follows seven key principles that guide QA processes:

1. **Testing shows presence of defects, not their absence** – You can demonstrate issues but never prove complete absence of defects ⚠️.  
2. **Exhaustive testing is impossible** – Testing every possible input combination is unfeasible. Focus on risk analysis and priorities 📝.  
3. **Early testing saves time and money** – Start testing as early as possible to catch defects when they are cheaper to fix ⏱️💰.  
4. **Defects cluster together** – A small number of modules often contain most defects, highlighting the need to focus testing efforts 🎯.  
5. **Beware of the pesticide paradox** – Repeating the same tests reduces their effectiveness; update and create new test cases regularly 🔄.  
6. **Testing is context-dependent** – Safety-critical applications require different approaches compared to web or e-commerce software ⚙️.  
7. **Absence of errors is a fallacy** – Fixing bugs alone does not guarantee software meets user needs; usability and functionality must be validated ✅.

---

## 📝 Test Scenarios and Test Cases

A **test scenario** is any functionality or feature that can be tested, helping to break complex systems into manageable parts and estimate effort 🔍. A **test case** is a sequence of steps designed to verify a specific path, including input, expected results, and actual results.

- **Positive Test Cases**: Verify correct behavior under normal conditions ✅.  
- **Negative Test Cases**: Check system response to unexpected or invalid inputs ❌.  

For example, a user login feature could have multiple test cases:  
- Login with valid credentials → Expected Result: Success  
- Login with invalid credentials → Expected Result: Error message ⚡

---

## 🐞 Bugs and Bug Tracking

Human errors can lead to software defects, known as **bugs** 🐛. These may occur in code, requirements, or design. If executed, bugs can cause failures, making software behave incorrectly. QA aims to detect and manage these defects efficiently.  

**Bug tracking** involves capturing, reporting, and managing bug data, enabling teams to collaborate and prevent recurring issues. Popular tools include **JIRA**, **Bugzilla**, and **Mantis** 🛠️.

---

## 🏗️ Test Levels

Testing occurs at multiple levels, each corresponding to different stages of software development:

1. **Unit Testing** – Focuses on individual components (functions, methods, modules) 🧩.  
2. **Integration Testing** – Verifies that components work together correctly, exposing interface issues 🔗.  
3. **System Testing** – Examines the software as a whole from an end-user perspective, including functional and non-functional requirements 🌐.  
4. **Acceptance Testing** – Validates end-to-end business flows, usually pre-deployment, performed by the business team or end-users (Alpha/Beta testing) ✅.

---

## ⚡ Test Types: Functional vs Non-Functional

- **Functional Testing** answers the question “What does the software do?” and validates specific actions like login, data processing, or transactions 🧩.  
- **Non-Functional Testing** answers “How does the software perform?” evaluating performance, security, usability, and reliability 🌟.

For example, an online banking system may undergo:  
- Functional: Validate login, fund transfer, payment processing 💳  
- Non-functional: Measure performance under load, ensure security, and check user interface usability 🛡️

Testing types can be applied at multiple levels and are essential to ensure both software functionality and quality. QA is about more than finding bugs – it ensures software works efficiently, safely, and reliably for end users 🌟.

---

QA mastery is fundamental for any software professional, as it guarantees that applications are robust, reliable, and meet both business and user expectations 💼.
